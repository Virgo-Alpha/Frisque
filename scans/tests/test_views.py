# frisque/scans/tests/test_views.py

import pytest
from django.urls import reverse
from django.contrib.auth import get_user_model
from allauth.account.models import EmailAddress
from unittest.mock import patch
from scans.models import ScanJob

# Get the custom User model
User = get_user_model()

@pytest.mark.django_db
class TestRunScanView:
    """
    Test suite for the RunScanView in the scans app.
    Verifies page loading, form submission (valid/invalid), and user authentication.
    """

    @pytest.fixture
    def client(self):
        """Provides a Django test client."""
        from django.test import Client
        return Client()

    @pytest.fixture
    def logged_in_user(self):
        """Creates and logs in a test user, returning the user object."""
        email = 'scanuser@example.com'
        password = 'ScanUserPass123!'
        user = User.objects.create_user(
            email=email,
            password=password,
            full_name='Scan'
        )
        EmailAddress.objects.create(
            user=user,
            email=email,
            primary=True,
            verified=True
        )
        return user

    def test_run_scan_page_loads_correctly_for_authenticated_user(self, client, logged_in_user):
        """
        Verify that the 'Run Scan' page loads successfully (HTTP 200) for an authenticated user.
        """
        # Log in the user
        client.force_login(logged_in_user) # pytest-django's convenient way to log in

        response = client.get(reverse('scans:run_scan'))

        assert response.status_code == 200
        assert 'scans/run_scan.html' in [t.name for t in response.templates]
        assert b"Initiate New Due Diligence Scan" in response.content # Check for page title

    def test_run_scan_page_redirects_unauthenticated_user_to_login(self, client):
        """
        Verify that an unauthenticated user is redirected from the 'Run Scan' page to the login page.
        """
        response = client.get(reverse('scans:run_scan'))

        assert response.status_code == 302
        # Check if it redirects to the LOGIN_URL (e.g., /login/) with a 'next' parameter
        assert response.url.startswith(reverse('login'))
        assert f"next={reverse('scans:run_scan')}" in response.url


    @patch('scans.views.perform_scan_task.delay')
    def test_submitting_form_with_valid_data(self, mock_delay, client, logged_in_user):
        """
        Verify that submitting the form with valid data dispatches the Celery task
        and results in a successful redirection to the new results page.
        """
        client.force_login(logged_in_user)
        
        valid_data = {
            'company_name': 'Test Company Inc.',
            'company_website': 'https://www.testcompany.com',
        }
        
        # Use follow=False to inspect the initial redirect response itself
        response = client.post(reverse('scans:run_scan'), data=valid_data, follow=False)
        
        # 1. Assert that the Celery task's .delay() method was called once
        mock_delay.assert_called_once()
        
        # 2. Assert that the response is a redirect (HTTP 302)
        assert response.status_code == 302
        
        # 3. Assert that the redirect URL is correct
        # Get the most recently created ScanJob to build the expected URL
        new_job = ScanJob.objects.latest('created_at')
        expected_url = reverse('scans:scan_result', kwargs={'pk': new_job.pk})
        assert response.url == expected_url

    def test_submitting_form_with_invalid_data_re_renders_page_with_errors(self, client, logged_in_user):
        """
        Verify that submitting the form with invalid data re-renders the page
        and displays validation errors.
        """
        client.force_login(logged_in_user)
        
        # Provide data that will trigger multiple validation errors
        invalid_data = {
            'company_name': '', # Missing required field
            'company_website': 'not-a-valid-url', # Invalid format
        }
        
        response = client.post(reverse('scans:run_scan'), data=invalid_data)
        
        # Should return 200 OK because it re-renders the same page with errors
        assert response.status_code == 200
        assert 'scans/run_scan.html' in [t.name for t in response.templates]
        
        # Check for the specific error messages generated by Django for each field
        content = response.content.decode()
        assert "Company name is a required field." in content
